
function createProfileInput(dataset, callback){

	if (Object.keys(dataset).length == 0) {
		callback({error: 'Dataset does not exists.'});
		return false;
	}
	
	var linksToUse = dataset.links;
	
	var graph = {};
	var nodes = {};
	var links = [];
	var existsProfile = {};
	var profileKey = {};
	var sameProfileHas = {};

	checkNodes(dataset, function(error){
		checkIsolates(dataset, function(){
			checkLinks(linksToUse, function(){
				
				graph.nodes = Object.keys(nodes).map(function(k) { return nodes[k] }); // nodeObject to array
				//console.log(graph.nodes.length);
				graph.links = links;
				graph.schemeGenes = dataset.schemegenes;
				graph.metadata = dataset.metadata;
				graph.key = dataset.key;
				graph.data_type = dataset.data_type;
				graph.dataset_name = dataset.name;
				graph.sequences = dataset.sequences;
				
				//if(Object.keys(dataset.distanceMatrix).length == 0) graph.distanceMatrix = {}; //graph.positions = JSON.parse(dataset.positions);
				//else graph.distanceMatrix = dataset.distanceMatrix;

				if(Object.keys(dataset.positions).length == 0) graph.positions = {}; //graph.positions = JSON.parse(dataset.positions);
				else graph.positions = dataset.positions;

				//getMissingData(dataset.profiles, function(missingData){
				//  graph.missingData = missingData;
                //  callback(graph);
                //});

				callback(graph);
				
			});
		});
	});

	function checkNodes(dataset, callback){

		dataset.profiles.forEach(function(profile){
			var sequence = "";
			var profileToUse = "";
			if(dataset.data_type == 'fasta'){
		    	profileToUse = profile.profile;
		    	sequence = profile.sequence;
		    }
		    else{
		    	profileToUse = profile;
		    }
			var arr = [];
			for (i in dataset.schemegenes) arr.push(profileToUse[dataset.schemegenes[i]]);
			//var arr = Object.keys(profile).map(function(k) { return profile[k] });
			var key = arr.shift();
			//arr = arr.reverse();
			var node = {key: key, profile: arr, isolates: [], sequence: sequence};

			
			if(existsProfile[String(arr)]) {
				sameProfileHas[String(key)] = profileKey[String(arr)];
				//console.log('profile already exists');
			}
			
			else{
				profileKey[String(arr)] = key;
				existsProfile[String(arr)] = true;
				nodes[key] = node;
			}
		});

		callback();
	}

	function checkIsolates(dataset, callback){

		dataset.isolates.forEach(function(isolate){

			if (sameProfileHas.hasOwnProperty(isolate[dataset.key])){
				isolate[dataset.key] = sameProfileHas[isolate[dataset.key]];
			}

			if(nodes[isolate[dataset.key]]){
				var arr = [];
				for (i in dataset.metadata) arr.push(isolate[dataset.metadata[i]]);
				//var arr = Object.keys(isolate).map(function(k) { return isolate[k]; });
			}

			try{
				nodes[isolate[dataset.key]].isolates.push(arr);
			}
			catch (err){
				var x = true;
			}
			
		});

		callback();
	}

	function checkLinks(linksToUse, callback){

		linksToUse.forEach(function(link){
			links.push({source: link.source, target: link.target, value: link.value, missings: link.missings});
		});

		callback();
	}
}


function getMissingData(data, callback){

  var profiles = data.map(function(k) { 
    var arrayToUse = Object.keys(k).map(function(z){
                    return k[z];
                  }); 

    return arrayToUse.slice(1,arrayToUse.length);
  });

  var missingDataArray = profiles.map(function(d,i){
    var countMissing = 0;
    d.map(function(x){
      if (x == "-" || x =="") countMissing += 1;
    });
    return countMissing;
  });

  callback(missingDataArray);



}


module.exports = function(dataset, callback){

	createProfileInput(dataset, function(graph){
		callback(graph);
	});
}